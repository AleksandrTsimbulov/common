# Задача на генерацию всех возможных к-сочетаний из n элементов
# на вход подается два числа k и n, для них гарантированно, что 0<=k<=n
# на выходе должно быть необходимое число строк из k чисел каждая

# организовываем ввод чисел и создаем исходный список
k, n = (int(i) for i in input().split( ))
#print(k, n)
a = [i for i in range(0, n)]
#print(a)

'''
Организовываем рекурсивную функцию на основе наблюдения о том, что все инстересующие
нас списки исходной функции можно разбить на две части:
а) списки, содержащие первый элемент вместе с различными комбинациями оставщихся элементов
(т.е. список функции уменьшается на "первый" элемент, количество сочетающихся с этим элементом
оставщихся элементов функции уменьшается на единицу, т.к. первый элемент уже выбран и является
частью сочетания)
б) списки, не содержащие первый элемент функция (список функции уменьшается на "первый"
элемент, количество сочетаний остается неизменным)

Если обозначить функцию f, список элементов n = list[], k - кол-во элементов подмножества, то
f(n,k) - испходная функция

При этом убедимся, что:
- если n = k, то подмножество единственное и результатом является n
- если k = 0, то результат - пустое множество
- если k = 1, то результат - перечень элементов множества n

'''
def f(a,k):
    res = []
    if k == 1 or k == len(a):
        for i in range(0, len(a)):
            res.append(a[i])
    else:
        b = f(a[1:], k-1)
        i = 0
        # c = len(a) -1
        while i < len(b):
            b.insert(i, a[0])
            i += k
        res = b + f(a[1:],k)
    #print(res)
    return res

if k == 0:
    print(end='')
else:
    counter = 0
    for j in f(a,k):
        print(j, end=' ')
        counter += 1
        if counter % k == 0:
            print()
